---
layout: article
category : articles
title :  Java Note
tagline: ""
tags : [Java]
image:
  feature:
  teaser: Java.png
---


# 专业术语
CDI（Contexts and Dependency Injection 上下文依赖注入），是JAVA官方提供的依赖注入实现，可用于Dynamic Web Module中

JSR：[Java Specification Requests](https://jcp.org/en/jsr/overview) (JSRs) are the actual descriptions of proposed and final specifications for the Java platform. At any one time there are numerous JSRs moving through the review and approval process.
JAX-RS: Java API for RESTful Web Services
[常用的JSR](https://www.shuzhiduo.com/A/VGzlAy9lJb/)

@SuppressWarnings This annotation allows us to say which kinds of warnings to ignore [Java @SuppressWarnings](https://www.baeldung.com/java-suppresswarnings)

JMM: Java Memory Model

# 问题

## Collection问题
Collections是工具类，在java.util，Collection是interface,

继承Map接口的类，想要用Iterator, 先要通过entrySet()转换为Set,entrySet来自接口Map

### How does HashMap work in Java
HashMap是基于hashing的原理，

我们使用put(key, value)存储对象到HashMap中，

使用get(key)从HashMap中获取对象。

当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象

作者：伊竹凌
链接：https://juejin.cn/post/6844903559322927112
来源：掘金


### HashMap vs HashTable

前者是非同步的，它不是线程安全的。HashTable是同步的，线程安全。

[HashMap vs HashTable](https://www.geeksforgeeks.org/differences-between-hashmap-and-hashtable-in-java/)

1. HashMap is non synchronized. It is not-thread safe and can’t be shared between many threads without proper synchronization code whereas Hashtable is synchronized. It is thread-safe and can be shared with many threads.
2. HashMap allows one null key and multiple null values whereas Hashtable doesn’t allow any null key or value.
3. HashMap is generally preferred over HashTable if thread synchronization is not needed

Why HashTable doesn’t allow null and HashMap does?
To successfully store and retrieve objects from a HashTable, the objects used as keys must implement the hashCode method and the equals method. Since null is not an object, it can’t implement these methods. HashMap is an advanced version and improvement on the Hashtable. HashMap was created later.

### Queue 的两个方法 poll()和 remove() 的区别
唯一的区别在于当queue为空时，: the remove() method throws an exception, while the poll() method returns null.
[官方资料](https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html)

### 如何从Collection类的对象中remove一条记录(entry)
Collection接口的类用remove(Object obj)

List接口的类还可以用remove(int index)在删除指定位置的记录

注意不可以在iterating时操作，否在出错

但是可以用Iterator's remove()方法在遍历list的时候删除

### Synchronized Collection 和 Concurrent Collection 区别
Concurrent Collection的类有ConcurrentHashMap, CopyOnWriteArrayList, BlockingQueue等

通过方法Collections.synchronizedMap()获得Synchronized HashMap

区别在于Concurrent Collection的类有更好的性能，因为他们只锁定Map的部分


### ArrayList vs Vector

[Vector vs ArrayList in Java](https://www.geeksforgeeks.org/vector-vs-arraylist-java/)
Vector是同步的，ArrayList是非同步的
Synchronization : Vector is synchronized, which means only one thread at a time can access the code, while arrayList is not synchronized

Performance: ArrayList is faster, since it is non-synchronized, while vector operations give slower performance since they are synchronized (thread-safe). 

Data Growth: ArrayList and Vector both grow and shrink dynamically to maintain optimal use of storage – but the way they resize is different. ArrayList increments 50% of the current array size if the number of elements exceeds its capacity, while vector increments 100% – essentially doubling the current array size.

Traversal: Vector can use both Enumeration and Iterator for traversing over elements of vector while ArrayList can only use Iterator for traversing.

Applications : Most of the time, programmers prefer ArrayList over Vector because ArrayList can be synchronized explicitly using Collections.synchronizedList.

###  Iterator and Enumeration 的区别
Iterator比Enumeration多了一个remove()方法

### HashSet是如何实现的
是通过HashMap, 将要插入的值作为HashMap的key,插入HashMap

因为HashMap的key是唯一的，从而实现HashSet的值的唯一性

### 如何排序
对于Collection类来说，调用sort(Comparator<V>()), 而V类需要继承Comparable

也可以调用Collections.sort()进行排序

### Hashtable VS ConcurrentHashMap
可以用ConcurrentHashMap代替Hashtable，需要改动的地方是
if(Hashtable.get(key) == null) put(key, value)
变为
putIfAbsent()

### CopyOnWriteArrayList ArrayList Vector
CopyOnWriteArrayList is thread-safe, ArrayList is not

CopyOnWriteArrayList 在read数据时，相对于Vector能够更好的处理并发性

### 为什么ListIterator有add（）方法但Iterator没有
ListIterator之所以添加了add()方法，是因为它能够在集合的两个方向上遍历或迭代。

它在上一个和下一个调用方面保持两个指针，并且可以在不影响当前迭代的情况下添加新元素。

[使用](https://blog.csdn.net/u012804490/article/details/29180561)

### LinkedList是如何用Java实现的，它是单链表还是双链表？ 
Linkedlist 是双向链表


## Thread问题

### Runnable and Callable 不同之处
Callable可以返回结果和抛出异常

### 什么是Java内存模型
Java内存模型是一组规则和准则，可让Java程序在多个内存体系结构，CPU和操作系统之间确定性地运行。

在多线程的情况下尤其重要。Java内存模型提供了某种保证，即一个线程所做的更改应对其他线程可见，其中之一是发生在关系之前。

这种关系定义了一些规则，这些规则使程序员可以预期并推理并发Java程序的行为。

### volatile 

volatile表示在变量将被多个线程更新，并且线程不应该缓存在变量的值

volatile保证Happen-before原则，即在被访问之前总是会被更新

[如何使用volatile](https://www.baeldung.com/java-volatile)

### CyclicBarrier and CountDownLatch不同之处
You can reuse CyclicBarrier after the barrier is broken but you cannot reuse CountDownLatch after the count reaches to zero

多个CyclicBarrier可以在同一个Runnable中执行不同的等待，相互之间不影响

CyclicBarrier(java.util.concurrent.CyclicBarrier) is a synchronization mechanism hat can synchronize threads progressing through some algorithm. 
[CyclicBarrier](http://tutorials.jenkov.com/java-util-concurrent/cyclicbarrier.html)

[CountDownLatch](https://www.baeldung.com/java-countdown-latch)

### How to share resources between threads
Can use static objects

Use [BlockingQueue](https://www.jianshu.com/p/b1408e3e3bb4)

### notify vs notifyAll
notify和notifyAll都在java.lang.Object上。

notify只能通知一个thread, 且不能指定

notifyAll通知所有在wait的线程

### Why wait, notify and notifyAll are not inside thread class?
因为java的lock是作用在object级别，而不是线程。

[参考](https://www.liaoxuefeng.com/wiki/1252599548343744/1306580911915042)

### ThreadLocal是什么
ThreadLocal是一个关于创建线程局部变量的类。

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。

而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。

[参考](https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/)

### FutureTask 
FutureTask一个可取消的异步计算，FutureTask 实现了Future的基本方法，

提空 start cancel 操作，可以查询计算是否已经完成，并且可以获取计算的结果。

结果只可以在计算完成之后获取，get方法会阻塞当计算没有完成的时候，一旦计算已经完成，那么计算就不能再次启动或是取消。

[用法](https://blog.csdn.net/chenliguan/article/details/54345993)

###  interrupted() and isInterrupted()

interrupted是一个静态方法，检查当前线程是否中断

isInterrupted是非静态方法，检查该线程是否中断

### Thread类的join方法作用
等待线程完成

在某些情况下，我们将不得不等待线程的完成。

例如，我们可能有一个程序，它将在执行其余执行之前开始初始化所需的资源。

我们可以将初始化任务作为线程运行，并等待其完成，然后再继续执行程序的其余部分。

为此，我们可以使用Thread类的join（）方法。当我们使用线程对象调用此方法时，它会暂停调用线程的执行，直到被调用的对象完成其执行为止。

[参考](https://www.cnblogs.com/duanxz/p/5038471.html)


### wait 和 sleep的区别
尽管wait和sleep都在Java应用程序中引入了某种形式的暂停，但它们是满足不同需求的工具。
Wait方法用于线程间通信，它在等待条件为true时放弃锁定，并在由于另一个线程等待条件的操作变为false时等待通知。
另一方面，sleep（）方法只是放弃CPU或在指定的持续时间内停止当前线程的执行。调用sleep方法不会释放当前线程持有的锁。

### What is thread pool? Why should you use thread pool in Java?
就时间和资源而言，创建线程是昂贵的。

如果在请求处理时创建线程，这会减慢响应时间，而且进程只能创建数量有限的线程。

为了避免这两个问题，在应用程序启动时将创建一个线程池，并将线程重新用于请求处理。该线程池称为“线程池”，而线程称为工作线程

通过 Executor framwork 实现

Executors.newCachedThreadPool()：无限线程池。

Executors.newFixedThreadPool(nThreads)：创建固定大小的线程池。

Executors.newSingleThreadExecutor()：创建单个线程的线程池。

### How do you avoid deadlock in Java? Write Code?
最简单的办法是避免循环等待 Circular Wait

### synchronized vs Lock

synchronized是一个keyword,

Lock是一个接口，实现它的类有 ReentrantLock

[Answer](https://stackoverflow.com/questions/4201713/synchronization-vs-lock)

### How do you check if a Thread holds a lock or not? 
Thread类有一个holdsLock(), 当且仅当当前线程hold住设定的对象时，返回true

### 如何保证线程顺序执行？

用join

### Thread的yield()作用
Yield方法是请求当前线程放弃CPU以便其他线程可以执行的一种方法。
Yield是一种静态方法，仅保证当前线程将放弃CPU，但不指明任何其他线程将获得CPU。

### 在ConcurrentHashMap中concurrency level是什么作用，如何设置？
concurrency level which is used as a hint for internal sizing.

### Semaphore 是什么

Semaphore 字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目。

[参考](https://www.jianshu.com/p/38630b7dbe73)
